freer-simple-1.3.0.0: unregistering (local file changes: bench/Core.hs)
Progress 0/2            freer-simple> configure (lib + exe + bench)
Progress 0/2            Configuring freer-simple-1.3.0.0...
Progress 0/2            freer-simple> build (lib + exe + bench)
Progress 0/2            Preprocessing library for freer-simple-1.3.0.0..
Progress 0/2            Building library for freer-simple-1.3.0.0..
Progress 0/2            Warning: Enabling workaround for Main module 'Main' listed in 'other-modules'
Progress 0/2            illegally!
Progress 0/2            Preprocessing benchmark 'core' for freer-simple-1.3.0.0..
Progress 0/2            Building benchmark 'core' for freer-simple-1.3.0.0..
Progress 0/2            [4 of 4] Compiling Main
Progress 0/2            Rule fired: unpack (GHC.Base)
Progress 0/2            Rule fired: unpack (GHC.Base)
Progress 0/2            Rule fired:
Progress 0/2                SPEC/Main $fMembertr @ (State Int) @ '[State Int, Identity] (Main)
Progress 0/2            Rule fired: Class op inj (BUILTIN)
Progress 0/2            Rule fired: SPEC/Main freer @ '[State Int, Identity] (Main)
Progress 0/2            Rule fired: Class op inj (BUILTIN)
Progress 0/2            Rule fired: SPEC/Main freer @ '[State Int, Identity] (Main)
Progress 0/2            Rule fired: Class op $p1Monad (BUILTIN)
Progress 0/2            Rule fired: Class op $p1Applicative (BUILTIN)
Progress 0/2            Rule fired: Class op fmap (BUILTIN)
Progress 0/2            Rule fired: Class op >>= (BUILTIN)
Progress 0/2            Rule fired: Class op return (BUILTIN)
Progress 0/2            Rule fired: Class op $p1Monad (BUILTIN)
Progress 0/2            Rule fired: Class op pure (BUILTIN)
Progress 0/2            Rule fired: Class op >>= (BUILTIN)
Progress 0/2            Rule fired: Class op $p1Monad (BUILTIN)
Progress 0/2            Rule fired: Class op pure (BUILTIN)
Progress 0/2            Rule fired: Class op $p1Monad (BUILTIN)
Progress 0/2            Rule fired: Class op pure (BUILTIN)
Progress 0/2            Rule fired: unpack-list (GHC.Base)
Progress 0/2            Rule fired: unpack-list (GHC.Base)
Progress 0/2            Rule fired: Class op $p1Monad (BUILTIN)
Progress 0/2            Rule fired: Class op >>= (BUILTIN)
Progress 0/2            Rule fired: Class op >>= (BUILTIN)
Progress 0/2            
Progress 0/2            ==================== Tidy Core ====================
Progress 0/2            Result size of Tidy Core
Progress 0/2              = {terms: 201, types: 565, coercions: 412, joins: 0/4}
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            main_x :: Int
Progress 0/2            main_x = I# 10000#
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 11, types: 12, coercions: 0, joins: 0/0}
Progress 0/2            main11 :: (Int, Int) -> ()
Progress 0/2            main11
Progress 0/2              = \ (ds :: (Int, Int)) ->
Progress 0/2                  case ds of { (x, y) ->
Progress 0/2                  case x of { I# ipv -> case y of { I# ipv1 -> () } }
Progress 0/2                  }
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            $trModule2 :: Addr#
Progress 0/2            $trModule2 = "Main"#
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            $trModule1 :: TrName
Progress 0/2            $trModule1 = TrNameS $trModule2
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            $trModule4 :: Addr#
Progress 0/2            $trModule4 = "main"#
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            $trModule3 :: TrName
Progress 0/2            $trModule3 = TrNameS $trModule4
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            $trModule :: Module
Progress 0/2            $trModule = Module $trModule3 $trModule1
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 23, coercions: 0, joins: 0/0}
Progress 0/2            u :: Union '[State Int, Identity] Int
Progress 0/2            u = Union 0## $WGet
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            lvl2 :: Addr#
Progress 0/2            lvl2 = "ww forall a. a -> m a"#
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 9, coercions: 0, joins: 0/0}
Progress 0/2            lvl3 :: forall (m :: * -> *) a. a -> m a
Progress 0/2            lvl3 = \ (@ (m :: * -> *)) -> absentError lvl2
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            lvl4 :: Addr#
Progress 0/2            lvl4 = "ww forall a b. m a -> m b -> m b"#
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 14, coercions: 0, joins: 0/0}
Progress 0/2            lvl5 :: forall (m :: * -> *) a b. m a -> m b -> m b
Progress 0/2            lvl5 = \ (@ (m :: * -> *)) -> absentError lvl4
Progress 0/2            
Progress 0/2            Rec {
Progress 0/2            -- RHS size: {terms: 46, types: 92, coercions: 21, joins: 0/4}
Progress 0/2            $w$sfreer
Progress 0/2              :: forall (m :: * -> *).
Progress 0/2                 Applicative m =>
Progress 0/2                 (forall a b. m a -> (a -> m b) -> m b)
Progress 0/2                 -> (forall x. Union '[State Int, Identity] x -> m x) -> m Int
Progress 0/2            $w$sfreer
Progress 0/2              = \ (@ (m :: * -> *))
Progress 0/2                  (ww :: Applicative m)
Progress 0/2                  (ww1 :: forall a b. m a -> (a -> m b) -> m b)
Progress 0/2                  (w :: forall x. Union '[State Int, Identity] x -> m x) ->
Progress 0/2                  let {
Progress 0/2                    lvl6 :: m Int
Progress 0/2                    lvl6 = ($sfreer `cast` <Co:20>) (C:Monad ww ww1 lvl5 lvl3) w } in
Progress 0/2                  let {
Progress 0/2                    lvl7 :: () -> m Int
Progress 0/2                    lvl7 = \ _ -> lvl6 } in
Progress 0/2                  ww1
Progress 0/2                    (w u)
Progress 0/2                    (\ (z :: Int) ->
Progress 0/2                       case z of wild { I# x ->
Progress 0/2                       case <=# x 0# of {
Progress 0/2                         __DEFAULT ->
Progress 0/2                           ww1
Progress 0/2                             (let {
Progress 0/2                                s1 :: Int#
Progress 0/2                                s1 = -# x 1# } in
Progress 0/2                              let {
Progress 0/2                                s2 :: Int
Progress 0/2                                s2 = I# s1 } in
Progress 0/2                              w (Union 0## (Modify @~ <Co:1> (\ _ -> s2))))
Progress 0/2                             lvl7;
Progress 0/2                         1# -> pure ww wild
Progress 0/2                       }
Progress 0/2                       })
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 10, types: 63, coercions: 0, joins: 0/0}
Progress 0/2            $sfreer1
Progress 0/2              :: forall (m :: * -> *).
Progress 0/2                 Monad m =>
Progress 0/2                 (forall x. Union '[State Int, Identity] x -> m x) -> m Int
Progress 0/2            $sfreer1
Progress 0/2              = \ (@ (m :: * -> *))
Progress 0/2                  (w :: Monad m)
Progress 0/2                  (w1 :: forall x. Union '[State Int, Identity] x -> m x) ->
Progress 0/2                  case w of { C:Monad ww1 ww2 ww3 ww4 -> $w$sfreer ww1 ww2 w1 }
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 21, joins: 0/0}
Progress 0/2            $sfreer :: Eff '[State Int, Identity] Int
Progress 0/2            $sfreer = $sfreer1 `cast` <Co:21>
Progress 0/2            end Rec }
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 2, types: 2, coercions: 0, joins: 0/0}
Progress 0/2            main10 :: Monad (StateT Int Identity)
Progress 0/2            main10 = $fMonadStateT $fMonadIdentity
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 27, types: 82, coercions: 267, joins: 0/0}
Progress 0/2            main9
Progress 0/2              :: forall x.
Progress 0/2                 Union '[State Int, Identity] x -> Int -> Identity (x, Int)
Progress 0/2            main9
Progress 0/2              = \ (@ x) (u1 :: Union '[State Int, Identity] x) (eta :: Int) ->
Progress 0/2                  case u1 of { Union @ t1 dt a1 ->
Progress 0/2                  case dt of {
Progress 0/2                    __DEFAULT -> (a1 `cast` <Co:9>, eta) `cast` <Co:5>;
Progress 0/2                    0## ->
Progress 0/2                      case a1 `cast` <Co:7> of {
Progress 0/2                        Get co -> (eta, eta) `cast` <Co:123>;
Progress 0/2                        Modify co f ->
Progress 0/2                          case f eta of vx { I# ipv -> ((), vx) `cast` <Co:123> }
Progress 0/2                      }
Progress 0/2                  }
Progress 0/2                  }
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 10, types: 11, coercions: 64, joins: 0/0}
Progress 0/2            main8 :: Int -> Identity (Int, Int)
Progress 0/2            main8
Progress 0/2              = \ (w :: Int) ->
Progress 0/2                  case (((($sfreer `cast` <Co:20>) main10 (main9 `cast` <Co:31>))
Progress 0/2                         `cast` <Co:4>)
Progress 0/2                          w)
Progress 0/2                       `cast` <Co:4>
Progress 0/2                  of
Progress 0/2                  { (a1, b1) ->
Progress 0/2                  (b1, a1) `cast` <Co:5>
Progress 0/2                  }
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            main15 :: Addr#
Progress 0/2            main15 = "Countdown Bench"#
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            main14 :: [Char]
Progress 0/2            main14 = unpackCString# main15
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            main13 :: Addr#
Progress 0/2            main13 = "countDown"#
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 2, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            main12 :: [Char]
Progress 0/2            main12 = unpackCString# main13
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 9, types: 8, coercions: 8, joins: 0/0}
Progress 0/2            main7
Progress 0/2              :: () -> Int64 -> State# RealWorld -> (# State# RealWorld, () #)
Progress 0/2            main7
Progress 0/2              = \ _ (eta :: Int64) (eta1 :: State# RealWorld) ->
Progress 0/2                  ((nf' main11 (main8 `cast` <Co:6>) main_x eta) `cast` <Co:2>) eta1
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 6, types: 1, coercions: 22, joins: 0/0}
Progress 0/2            main6 :: Benchmarkable
Progress 0/2            main6
Progress 0/2              = Benchmarkable
Progress 0/2                  (nf3 `cast` <Co:3>)
Progress 0/2                  (nf2 `cast` <Co:5>)
Progress 0/2                  (nf1 `cast` <Co:7>)
Progress 0/2                  (main7 `cast` <Co:7>)
Progress 0/2                  False
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            main5 :: Benchmark
Progress 0/2            main5 = Benchmark main12 main6
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Progress 0/2            main4 :: [Benchmark]
Progress 0/2            main4 = : main5 []
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            main3 :: Benchmark
Progress 0/2            main3 = BenchGroup main14 main4
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 2, coercions: 0, joins: 0/0}
Progress 0/2            main2 :: [Benchmark]
Progress 0/2            main2 = : main3 []
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 3, types: 0, coercions: 0, joins: 0/0}
Progress 0/2            main1 :: State# RealWorld -> (# State# RealWorld, () #)
Progress 0/2            main1 = defaultMain2 defaultConfig main2
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Progress 0/2            main :: IO ()
Progress 0/2            main = main1 `cast` <Co:3>
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 2, types: 1, coercions: 3, joins: 0/0}
Progress 0/2            main16 :: State# RealWorld -> (# State# RealWorld, () #)
Progress 0/2            main16 = runMainIO1 (main1 `cast` <Co:3>)
Progress 0/2            
Progress 0/2            -- RHS size: {terms: 1, types: 0, coercions: 3, joins: 0/0}
Progress 0/2            main :: IO ()
Progress 0/2            main = main16 `cast` <Co:3>
Progress 0/2            
Progress 0/2            
Progress 0/2            ------ Local rules for imported ids --------
Progress 0/2            "SPEC/Main freer @ '[State Int, Identity]"
Progress 0/2                forall ($dMember :: Member (State Int) '[State Int, Identity]).
Progress 0/2                  freer $dMember
Progress 0/2                  = $sfreer
Progress 0/2            
Progress 0/2            
Progress 0/2            Linking .stack-work/dist/x86_64-linux-tinfo6/Cabal-3.2.1.0/build/core/core ...
Progress 0/2            Preprocessing executable 'freer-examples' for freer-simple-1.3.0.0..
Progress 0/2            Building executable 'freer-examples' for freer-simple-1.3.0.0..
Progress 0/2            freer-simple> copy/register
Progress 0/2            Installing library in /home/haskeller/dev/freer-simple/.stack-work/install/x86_64-linux-tinfo6/d62049a83faed46b276c2351c0f98d4e98224f2fa4bfd42f4c841914c3d8843a/8.10.4/lib/x86_64-linux-ghc-8.10.4/freer-simple-1.3.0.0-IgwfuwjYq942jOW0YdKNZy
Progress 0/2            Installing executable freer-examples in /home/haskeller/dev/freer-simple/.stack-work/install/x86_64-linux-tinfo6/d62049a83faed46b276c2351c0f98d4e98224f2fa4bfd42f4c841914c3d8843a/8.10.4/bin
Progress 0/2            Registering library for freer-simple-1.3.0.0..
Progress 0/2            freer-simple> benchmarks
Progress 0/2            Progress 1/2: freer-simple                          Running 1 benchmarks...
Progress 1/2: freer-simple                          Benchmark core: RUNNING...
Progress 1/2: freer-simple                          benchmarking Countdown Bench/countDown
Progress 1/2: freer-simple                          time                 1.178 ms   (1.173 ms .. 1.184 ms)
Progress 1/2: freer-simple                                               1.000 R²   (0.999 R² .. 1.000 R²)
Progress 1/2: freer-simple                          mean                 1.181 ms   (1.172 ms .. 1.202 ms)
Progress 1/2: freer-simple                          std dev              42.91 μs   (15.26 μs .. 86.97 μs)
Progress 1/2: freer-simple                          variance introduced by outliers: 24% (moderately inflated)
Progress 1/2: freer-simple                          
Progress 1/2: freer-simple                          Benchmark core: FINISH
Progress 1/2: freer-simple                          Completed 2 action(s).
